#!/bin/bash
# Functions library :: for Linux Live scripts
# Author: Tomas Matejicek <http://www.linux-live.org>
#

# echolog
# $1 = text to show and to write to /var/log/messages
#
echolog()
{
   echo "LIVECD:" "$@" >>/var/log/livedbg
   echo "$@"
}

# header
# $1 = text to show
#
header()
{
   echolog " "
   echolog "+============================================================================="
   echolog "| $1:"
   echolog "+============================================================================="
   echolog " "
}

# file extension
# $1 = filename with extension
# return: whole extension
#
file_extension()
{
   echo "$1" | egrep -io "\\.[^.]*\$"
}

# look into cmdline and echo $1 back if $1 is set
# $1 = value name, case sensitive, for example livecd_subdir
# $2 = file to use instead /proc/cmdline, optional
#
cmdline_parameter()
{
   CMDLINE=/proc/cmdline
   if [ ! "$2" = "" ]; then CMDLINE="$2"; fi
   cat "$CMDLINE" | egrep -io "(^|[[:space:]]+)$1(\$|=|[[:space:]]+)" | egrep -o "[^[:space:]].*[^[:space:]]"
}

# look into cmdline and echo value of $1 option
# $1 = value name, case sensitive, for example livecd_subdir
# $2 = file to use instead /proc/cmdline, optional
#
cmdline_value()
{
   CMDLINE=/proc/cmdline
   if [ ! "$2" = "" ]; then CMDLINE="$2"; fi
   cat "$CMDLINE" | egrep -io "(^|[[:space:]]+)$1=([^[:space:]]+)" | egrep -o "[^=]+\$" | tail -n 1
}

# create temporary file (empty)
# $1 = prefix
#
tempfile()
{
   local NAME=$1
   if [ "$NAME" = "" ]; then NAME="/tmp/tempfile"; fi
   while [ -a "$NAME" ]; do
      NAME=$NAME".X"
   done
   touch "$NAME"
   echolog "$NAME"
}

# create temp directory in $1 with the preffix $2
# $1 = prefix to use, it may be a fullpath too
# (for example tempdir /mnt/cdrom/bin.img /mnt will create /mnt/bin.KJBDRTYH)
# $2 = subdirectory where tempdir will be created
#
tempdir()
{
   local TMPDIR
   if [ "$2" != "" ]; then TMPDIR="$2"; else TMPDIR="/tmp"; fi
   local MOUNTPOINT=`basename $1`

   MOUNTPOINT="$TMPDIR/$MOUNTPOINT"

   while [ -a "$MOUNTPOINT" ]; do
      MOUNTPOINT=$MOUNTPOINT".X"
   done

   mkdir -p "$MOUNTPOINT"
   if [ $? != 0 ]; then echolog "error creating directory $MOUNTPOINT"; exit 1; fi
   echolog "$MOUNTPOINT"
}

# create compressed iso image
# $1 = input directory tree (for example /bin)
# $2 = output img file (for example /tmp/bin.iso)
# $3 = relative root dir string (for example /bin)
#
mkciso()
{
   RAW=`tempfile`
   COMPRESSED=`tempfile`
   if [ "$3" != "" ]; then INPUT="-graft-points $3=$1"; else INPUT="$1"; fi

   mkisofs -R -J -D -o "$RAW" $INPUT 2>/dev/null
   mkzftree -z 9 -F "$RAW" "$COMPRESSED"
   if [ ! "$?" = 0 ]; then
      echolog "mkzftree error: directory $1 is very big? Maybe you are running"
      echolog "out of disk space, or mkzftree doesn't support large files,"
      echolog "or mkzftree not found! (get it from cdrtools package)"
      return 1
   fi
   rm -f "$RAW" # it won't be needed anymore

   mkisofs -R -J -D -z -o "$2" -graft-points mountme.iso=$COMPRESSED 2>/dev/null
   rm -f "$COMPRESSED"
}

# link all files and directories from $1/* to $2; recursive function
# $1 = source directory
# $2 = destination directory
# $3 = directory to strip, usually /mnt
#
make_links()
{
   local SOURCEDIR="`dirname \"$1/x\"`"
   ls -aA1b "$SOURCEDIR" 2>/dev/null | while read FILE;
   do
      local DESTFILE="$2/$FILE"

      if [ -L "$SOURCEDIR/$FILE" ]; then
         rm -rf "$DESTFILE"
         ln -sf "`readlink \"$SOURCEDIR/$FILE\"`" "$DESTFILE"
      else
         if [ -d "$SOURCEDIR/$FILE" ]; then
            if [ "`ls -aA \"$DESTFILE\" 2>/dev/null`" = "" ]; then
	       mkdir -p "$DESTFILE"
	       if [ "`ls -aA \"$SOURCEDIR/$FILE\" 2>/dev/null`" != ""  ]; then
	          mount -n --rbind "$SOURCEDIR/$FILE" "$DESTFILE"
	       fi
            else
      	       make_writable "$DESTFILE" $3
               make_links "$SOURCEDIR/$FILE" "$DESTFILE" $3
	    fi
	 else
            rm -rf "$DESTFILE"
	    ln -sf "${SOURCEDIR:${#3}}/$FILE" "$DESTFILE"
	 fi
      fi
   done
}

# make a symlink to file or directory writable in LiveCD linked tree; recursive
# $1 = directory or file I would like to write to
# $2 = stripped directory which has to be added back now
#
make_writable()
{
   # not a symlink? exit
   if [ ! -L "$1" ]; then
      return 1
   fi

   local LINKPOINT="$2""`readlink \"$1\"`"

   if [ -d "$1" ]; then            # symlink to a directory?
      rm -f "$1"                   # remove link
      mkdir "$1"                   # create real directory instead of it
      make_links "$LINKPOINT" "$1" # and link the content
   else                            # symlink to a file?
      cp -fR "$LINKPOINT" "$1"     # then just copy the original here
   fi
}

# try to copy all images to RAM, if commandline parameter copy2ram or toram is present
# $1 = path to compressed image
# $2 = destination path
# return: will echo the final destination of image (the original path if not copied to RAM, or the copy)
#
cp2ram()
{
   DOCOPY="`cmdline_parameter copy2ram`"
   if [ "$DOCOPY" = "" ]; then DOCOPY="`cmdline_parameter toram`"; fi
   IMGNAME="`basename \"$1\"`"

   if [ ! "$DOCOPY" = "" ]; then
      echolog -n " $IMGNAME" >&2
      cp "$1" "$2/$IMGNAME"

      if [ $? = 0 ];
         then echolog "$2/$IMGNAME"; return 0
         else rm -f "$2/$IMGNAME" # not enough free space?
      fi
   fi
   echolog "$1"
}

# mount image into unique temporary directory
# $1 = image to mount
# $2 = where to create a tmpdir
# $3 = storage textfile, append mountpoint path there
# $4 = mount arguments, for example -n will disable writing to /etc/mtab
#
mount_img()
{
   local MOUNTPOINT=`tempdir $1 $2`
   mount $4 -o loop,ro $1 $MOUNTPOINT
   if [ $? != 0 ]; then
      echolog "!error mounting $1 to $MOUNTPOINT"
      echolog "Do you have enough free loop devices?"
      echolog "Or IMG file is corrupted? Can you check md5sum?"
      return 1
   fi

   mount $4 -o loop,ro $MOUNTPOINT/mountme.iso $MOUNTPOINT
   if [ $? != 0 ]; then
      echolog "!error submounting $1"
      echolog "Do you have enough free loop devices?"
      echolog "Do you have transparent decompression for ISO filesystem compiled into kernel?"
      return 1
   fi
   
   echolog "$MOUNTPOINT" >>$3
}

# REmount device in $1 directory, in the mode set by $2
# $1 = directory which is already mounted
# $2 = mount option for -o remount,("ro", "rw")
#
remount()
{
   mount -o remount,$2 "`cat /proc/mounts | grep \"$1\" | cut -d \" \" -f 1`" $1 2>/dev/null
}

# Mount device $1 to $2
# $1 = /dev device to mount
# $2 = /mnt mountpoint, directory will be created automatically
# $3 = mount options, for example "loop" or "remount,ro"
#
mount_device()
{
  if [ -a "$2" -o ! -b "$1" ]; then return 1; fi # only mount if directory doesn't exist
  mkdir -p $2
  if [ "$3" != "" ]; then OPTIONS="-o $3"; fi

  PRINTK=`cat /proc/sys/kernel/printk`
  echo "0" >/proc/sys/kernel/printk

  mount -t auto $OPTIONS $1 $2 >/dev/null 2>/dev/null
  err=$?

  if [ "$err" != 0 ]; then rmdir $2; fi
  echo "$PRINTK" >/proc/sys/kernel/printk
  return $err
}

# modprobe module $1, suppress all messages
# $1 = module name, eg. ehci-hcd
#
modprobe_module()
{
  PRINTK=`cat /proc/sys/kernel/printk`
  echo "0" >/proc/sys/kernel/printk

  modprobe $1 >/dev/null 2>/dev/null
  err=$?

  echo "$PRINTK" >/proc/sys/kernel/printk
  return $err
}

# List all CD-ROMs
# by using /dev entries (mounted devfs filesystem)
#
list_all_cdroms()
{
   CDIR=/dev/cdroms
   if [ ! -d "$CDIR" ]; then return 0; fi
   ls -aAb1 "$CDIR" | while read FILE ; # list all files in directory
   do
      echo "$CDIR/$FILE"
   done
}

# Mount all CDs to $1
# $1 = mount directory, in which all CDs will be mounted, eg. /mnt/mnt
# return: echo all mounted devices
# This won't include empty CD-ROMs!
#
mount_all_cds()
{
   list_all_cdroms | while read DEVICE ;
   do
      FILE="`basename $DEVICE`"
      CDDEV="`readlink -f $DEVICE`"
      mount_device "$CDDEV" "$1/$FILE" ro
      echolog "$CDDEV"
   done
}

# Mount all discs to $1
# $1 = mount directory, in which all discs will be mounted,  eg. /mnt/mnt
# return: echo all mounted devices
#
mount_all_discs()
{
   DDIR=/dev/discs
   if [ ! -d $DDIR ]; then return 0; fi
   ls -aAb1 $DDIR | while read DISC ; # list all files in directory
   do
      ls -aAb1 "$DDIR/$DISC" | grep part | while read PART;
      do
         mount_device "$DDIR/$DISC/$PART" "$1/$DISC$PART" ro
	 echolog "$DDIR/$DISC/$PART"
      done
   done
}

# Find all swaps and write info for fstab to stdout
#
list_swaps()
{
   /sbin/fdisk -l 2>/dev/null | grep -i "Linux swap" | egrep -o "^/dev/[a-z0-9/]+" | while read LINE;
   do
      echolog "$LINE swap swap defaults 0 0"
   done
}

# list all library dependencies, using ldd, including all links
# $1 = binary
#
list_libs()
{
   ldd "$1" | egrep -o "[[:space:]]/.*" | cut -b 2- | cut -d " " -f 1 | while read LIB; do
     echo "$LIB"
     if [ -L "$LIB" ]; then LIB="`dirname $LIB`/`readlink $LIB`"; echo $LIB; fi
     list_libs $LIB # even a library could use libraries
   done
}

# rcopy is a recursive cp, which copies also symlink's real source
# $1 = source (may be a regular file or symlink)
# $2 = target PARENT
#
rcopy()
{
   if [ -L "$1" ]; then
      REALPATH="`readlink -f \"$1\"`"
      cp --parent -R "$REALPATH" "$2"
      ln -sf "$REALPATH" "$2/$1"
   else
      cp --parent -R "$1" "$2"
   fi
   if [ "$?" -ne 0 ]; then
      echo "---------------------------"
      echo "Error occured while trying to copy \"$1\" to \"$2\""
      echo "nevertheless your LiveCD may still work."
      echo "Possible reason: not enough free space in initrd or source doesn't exist"
      echo "---------------------------"
   fi
}

# copy file/dir only if it exists, else skip with no error
# $1 = source (may not exist)
# $2 = target PARENT
#
rcopy_ex()
{
   if [ -a "$1" ]; then
      rcopy "$1" "$2"
   fi
}
