#!/bin/ash

# Functions library :: for Linux Live scripts 6.x.y
# Author: Tomas M. <http://www.linux-live.org>
#

# ===========================================================
# GLOBAL variables
# ===========================================================

# linux live flag to fstab, if fstab line doesn't contain it,
# never remove it from fstab automatically (user added it)
FSTABLLFLAG="# AutoUpdate"

# We have to set these variables very carefully
UNION=union
MEMORY=memory
MOUNTDIR=mnt
CHANGES=$MEMORY/changes
COPY2RAM=$MEMORY/copy2ram
IMAGES=$MEMORY/images
INITRAMDISK=$MOUNTDIR/live
LOOPMOUNT=$MOUNTDIR/tmp

# this will be replaced by build script, so don't change the following line!
LIVECDNAME="linux"

# debug function

DEBUG_IS_ENABLED=`cat /proc/cmdline 2>/dev/null | grep debug`

if_debug()
{
   if [ "$DEBUG_IS_ENABLED" ]; then
      echo "- debug: $*" >&2
   fi
}

# ===========================================================
# user interface functions
# ===========================================================

# echogreen will echo $@ in green color
# $1 = text
#
echogreen()
{
   echo -ne "[0;32m""$@""[0;39m"
}

# echolog
# $1 = text to show and to write to /var/log/messages
#
echolog()
{
   if [ "$1" != "" ]; then
      echogreen "* "
      log "LIVECD:" "$@" 
      echo "$@"
   fi
}

# log
# store given text in /var/log/livedbg
log()
{
   echo "$@" >>/var/log/livedbg
}

# debug
# commands executed when debug boot parameter is present
#
debug()
{
   echo
   echo "====="
   echo ": Debugging started. Here is the root shell for you."
   echo ": Type your desired command or hit Ctrl+D to continue booting."
   echo
   ash < /dev/console
   echo
}

# header
# $1 = text to show
#
header()
{
   echo "[0;1m""$@""[0;0m"
}

fatal()
{
   echolog
   header "Fatal error occured - $1"
   echolog "Something went wrong and we can't continue. This should never happen."
   echolog "Please reboot your computer with Ctrl+Alt+Delete ..."
   echolog
   umount -a -r 2>/dev/null
   mount -t proc proc /proc
   mount -t sysfs sysfs /sys
   ash < /dev/console
}

allow_only_root()
{
  # test if the script is started by root user. If not, exit
  if [ "0$UID" -ne 0 ]; then
     echo "Only root can run `basename $0`"; exit 1
  fi
}

# ===========================================================
# text processing functions
# ===========================================================

# egrep_o is a replacement for "egrep -o". It prints only the last
# matching text
# $1 = regular expression
#
egrep_o()
{
   if_debug "egrep_o" "$*"
   local SED
   SED="`echo \"$1\" | sed -r 's/\\//\\\\\\//g'`"
   cat | egrep "$1" | sed -r "s/.*$SED.*/\\1/" 2>/dev/null
}

# look into cmdline and echo $1 back if $1 is set
# $1 = value name, case sensitive, for example changes
#
cmdline_parameter()
{
   if_debug "cmdline_paraneter" "$*"
   log "searching for boot param: $1"
   cat /proc/cmdline | egrep_o "((^|[[:space:]]+)$1(\$|=|[[:space:]]+))" | egrep_o "($1)"
}

# look into cmdline and echo value of $1 option
# $1 = value name, case sensitive, for example livecd_subdir
# $2 = file to use instead /proc/cmdline, optional
#
cmdline_value()
{
   if_debug "cmdline_value" "$*"
   log "searching for bootparam value: $1"
   cat /proc/cmdline | egrep_o "((^|[[:space:]]+)$1=([^[:space:]]+))" | egrep_o "(=.*)" | cut -b 2- | tail -n 1
}

# ===========================================================
# system functions
# ===========================================================

# setup /usr from /usr.lzm inside initrd
mount_initrd_loops()
{
   if_debug "mount_initrd_loops" "$*"
   if [ -e /usr.lzm ]; then
      mount -n -t squashfs -o loop /usr.lzm /usr
   fi
}

# modprobe module $1, including all dependencies, suppress all messages
# (own function because modprobe in busybox doesn't work with gzipped modules)
# $1 = module name, eg. ehci-hcd
# $* = optional arguments
#
modprobe_module()
{
   if_debug "modprobe_module" "$*"
   local MODULE
  
   MODULE="$1"
   shift

   if [ ! "$MODULE" ]; then return 1; fi
   modprobe "$MODULE" $* 2>/dev/null
}

# mknod next loop device
# - find biggest loop device in /dev/loop/
# - mknod nearest bigger one.
# - kernel must have support for it
mknod_next_loop_dev()
{
   if_debug "mknod_next_loop_dev" "$*"
   local NR PFX

   if [ -d /dev/loop ]; then
      NR="`ls -1vA /dev/loop/ | tail -n 1`"
      PFX="/"
   else
      NR="`ls -1vA /dev/ | grep loop | sed -r 's/[^0-9]+//' | tail -n 1`"
      PFX=""
   fi
   NR="`expr 0$NR + 1`"
   mknod /dev/loop$PFX$NR b 7 $NR 2>/dev/null
   echo /dev/loop$PFX$NR
}

# Mount device $1 to $2
# If the device is using vfat or ntfs filesystem, use iocharset as a mount option
# $1 = /dev device to mount, eg. /dev/hda1, or loop file, or directory
# $2 = mountpoint, eg. /mnt/hda1
# $3 = optional mount options, for example "ro", or "remount,rw"
#
mount_device()
{
   if_debug "mount_device" "$*"
   local DEV LOOPDEV OPTIONS PRINTK FILESYSTEM ERR

   # make sure we have enough arguments
   if [ "$2" = "" ]; then return 1; fi
   mkdir -p "$2"

   DEV="$1"
   OPTIONS=$(fs_options `device_filesystem $1` mount)
   if [ "$OPTIONS" ]; then OPTIONS="noatime,$OPTIONS"; else OPTIONS="noatime"; fi
   if [ -f "$DEV" ]; then OPTIONS="$OPTIONS,loop"; fi
   if [ -d "$DEV" ]; then OPTIONS="$OPTIONS,rbind"; fi
   if [ "$3" ]; then OPTIONS="$OPTIONS,$3"; fi

   PRINTK=`cat /proc/sys/kernel/printk`
   echo "0" >/proc/sys/kernel/printk

   mount -n -o $OPTIONS "$DEV" "$2" >/dev/null 2>&1
   ERR=$?

   # not enough loop devices? try to create one. Usually kernel can't use it anyway
   # if minor>max_loop, but Slax uses loop.c patch for kernel so it IS usable.
   if [ $ERR -eq 2 ]; then
       LOOPDEV="`mknod_next_loop_dev`"
       OPTIONS=$(echo "$OPTIONS" | sed -r "s/,loop//")
       losetup "$LOOPDEV" "$DEV" >/dev/null 2>&1
       mount -n -o $OPTIONS "$LOOPDEV" "$2" >/dev/null 2>&1
       ERR=$?
   fi

   # if nothing works, try to force read-only mount
   if [ $ERR -ne 0 ]; then
       mount -n -r -o $OPTIONS "$DEV" "$2" >/dev/null 2>&1
       ERR=$?
   fi

   if [ $ERR -ne 0 ]; then rmdir $2 2>/dev/null; fi
   echo "$PRINTK" >/proc/sys/kernel/printk
   return $ERR
}

# Force unmount of all parameters
# $1..$n = directories to be unmounted
#
fumount()
{
   if_debug "fumount" "$*"
   while [ "$1" ]; do
      umount -n "$1" >/dev/null 2>&1
      if [ $? -ne 0 ]; then
         mount -n -o remount,ro -t ignored ignored "$1" >/dev/null 2>&1
         umount -n -l "$1" >/dev/null 2>&1
      fi
      shift
   done
}

# ===========================================================
# live module functions
# ===========================================================

# Create module
# call mksquashfs with apropriate arguments
# $1 = directory which will be compressed to squashfs module
# $2 = output filesystem module file
# $3 = optional -keep-as-directory argument
#
create_module()
{
   if_debug "create_module" "$*"
   mksquashfs "$1" "$2" $3 >/dev/null
   if [ $? -ne 0 ]; then return 1; fi
   chmod oga-wx "$2" # remove execute attrib
}

# Mountpoint exits with 0 if $1 is mountpoint, else exits with 1
# $1 = directory
#
mountpoint()
{
   if_debug "mountpoint" "$*"
   local MDIR

   MDIR="`readlink -f $1`"
   cat /proc/mounts | cut -d " " -f 2 | egrep "^$MDIR\$" >/dev/null 2>&1
}

# Mount filesystem module to destination directory
# $1 = path to the compressed module
# $2 = destination folder
#
mount_module()
{
   if_debug "mount_module" "$*"
   local ERR

   mount -n -t squashfs -o loop,ro "$1" "$2"
   ERR=$?
   if [ 0$ERR -eq 0 ]; then
      echo "$1 $2" >>/tmp/_mounts
   fi
   return $ERR
}

# Insert a directory tree $2 to an union specified by $1
# Top-level read-write branch is specified by it's index 0
# $1 = union absolute path (starting with /)
# $2 = path to data directory
#
union_insert_dir()
{
   if_debug "union_insert_dir" "$*"
   mount -n -o remount,add:1:$2=ro aufs $1
}

# List all modules in all directories (base, modules, optional)
# and filter out unneeded optional modules (not specified by load= kernel parameter)
# separator for load and noload arguments is "," or ";"
# $1 = root directory of mounted DATAdir
#
list_modules()
{
   if_debug "list_modules" "$*"
   local LOAD NOLOAD

   LOAD="`cmdline_value load | sed -r 's/\*/.\*/g' | sed -r 's/,|;/|/g'`"
   NOLOAD="`cmdline_value noload | sed -r 's/\*/.\*/g' | sed -r 's/,|;/|/g'`"
   find $1/base $1/modules $1/optional -name "*.lzm" 2>/dev/null | sort | while read LINE; do
      MODNAME="`echo $LINE | cut -b ${#1}- | cut -b 2-`"
      if [ "`echo $LINE | grep /optional/`" ]; then
         if [ ! "$LOAD" -o ! "`echo $MODNAME | egrep -i \"$LOAD\"`" ]; then continue; fi
      fi
      if [ "$NOLOAD" -a "`echo $MODNAME | egrep -i \"$NOLOAD\"`" ]; then continue; fi
      echo $LINE
   done
}

# Insert one single filesystem module to the union
# $1 = union absolute path
# $2 = module full path
# $3 = destination folder, where images will be mounted to
# $4 = preffix length strip (number of characters)
#
union_insert_module()
{
   if_debug "union_insert_module" "$*"
   local TARGET

   TARGET="$3/`basename $2`"
   if mountpoint $TARGET >/dev/null 2>&1; then return; fi # skip mounted modules
   mkdir -p $TARGET
   mount_module $2 $TARGET
   if [ $? -ne 0 ]; then echo "Cannot read module data. corrupted download?" >&2; return 1; fi
   union_insert_dir $1 $TARGET
   if [ $? -ne 0 ]; then echo "can't insert module to union" >&2; return 2; fi
   echo "$2" | cut -b $4- | cut -b 2-
   echolog "$2" >/dev/null
   return 0
}

# Insert all filesystem modules, in $2 directory and subdirectories, to the union
# $1 = union absolute path (starting with /)
# $2 = LiveCD data dir (with directories /base, /modules, etc.)
# $3 = destination folder, where images will be mounted to
#
union_insert_modules()
{
   if_debug "union_insert_modules" "$*"
   list_modules $2 | while read MODULE; do
      echolog -n " -> "
      union_insert_module $1 $MODULE $3 ${#2}
   done
}

# Copy LiveCD modules to RAM directory
# will copy only /boot, and module files from $1
# $1 = data directory
# $2 = target directory in RAM
#
copy_to_ram()
{
   if_debug "copy_to_ram" "$*"
   cp -a "$1/rootcopy" "$2" 2>/dev/null # could be empty
   list_modules "$1" | while read MODULE; do
      TARGET="$2/`basename \`dirname $MODULE\``"
      mkdir -p "$TARGET"
      cp "$MODULE" "$TARGET"
      if [ $? -ne 0 ]; then fatal "Not enough memory. Using ramsize=$RAMSIZE"; fi
   done
}

# ===========================================================
# discovery functions
# ===========================================================

# List all CD-ROMs
# by using /proc entries
#
list_cdrom_devices()
{
   if_debug "list_cdrom_devices" "$*"
   local CDDEVICE

   if [ "`cmdline_parameter nocd`" != "" ]; then return 1; fi
   for CDDEVICE in `cat /proc/sys/dev/cdrom/info 2>/dev/null | head -n 3 | tail -n 1 | cut -d ":" -f 2`; do
      echo "/dev/$CDDEVICE"
   done
}

# List all mounted directories
#
list_mounted_directories()
{
   if_debug "list_mounted_directories" "$*"
   if [ "$MOUNTDIR" ]; then
      ls -1 $MOUNTDIR | while read DIR; do
         if mountpoint $MOUNTDIR/$DIR; then echo $DIR; fi
      done
   fi
}

# List all devices with filesystems
# Return empty result when nohd parameter was given.
#
list_partition_devices()
{
   if_debug "list_partition_devices" "$*"
   if [ "`cmdline_parameter nohd`" != "" ]; then return 1; fi
   cat /proc/partitions | grep -v loop | grep -v major | grep -v "^\$" | sed -r "s/^[0-9 ]+/\\/dev\\//"
}

# List all disk devices
#
list_disk_devices()
{
   if_debug "list_disk_devices" "$*"
   list_partition_devices | egrep -v "[0-9]"
}

# List all partitions marked as Linux Swap
#
list_swap_devices()
{
   if_debug "list_swap_devices" "$*"
   if [ "`cmdline_parameter nohd`" != "" -o "`cmdline_parameter noswap`" != "" ]; then return 1; fi
   blkid -t TYPE="swap" | cut -d : -f 1
}

# List all block devices
#
list_block_devices()
{
   if_debug "list_block_devices" "$*"
   list_cdrom_devices
   list_partition_devices
}

# create mountdir for device, so KDE can easily assing an icon for it
# based on the directory name (using _cdrom or _removable suffix)
# $1 = device full path
#
device_mountdir()
{
   if_debug "device_mountdir" "$*"
   local REMOVABLE DEV DEVMBR MEDIA SUFFIX

   DEV="`basename $1`"
   DEVMBR="`echo $DEV | sed -r 's/[0-9]+\$//'`"
   REMOVABLE="`cat /sys/block/$DEVMBR/removable 2>/dev/null`"
   MEDIA="`cat /sys/block/$DEVMBR/device/media 2>/dev/null`"

   if [ "$MEDIA" != "" -a "$MEDIA" != "disk" ]; then
      SUFFIX="_$MEDIA"
   elif [ "$REMOVABLE" -eq 1 ]; then
      SUFFIX="_removable"
   fi
   echo "/$MOUNTDIR/$DEV$SUFFIX" | tr -s /
}

# Find file-path on given device
# First it mounts the device read-only. If then the 'path' is found, 
# then remount without RO flag (causes it to be mounted read-write if possible)
# and return the path, else unmount and exit.
# If the device/dev_directory is already mounted, preserve it mounted
# $1 = device
# $2 = path/filename
#
find_filepath()
{
   if_debug "find_filepath" "$*"
   local DIR FOUND PRESERVE

   DIR="`device_mountdir $1`"
   mountpoint $DIR >/dev/null 2>&1
   if [ $? -eq 0 ]; then
      PRESERVE="true"
   else
      mount_device $1 $DIR ro
      if [ $? -ne 0 ]; then rmdir $DIR 2>/dev/null; return 1; fi
      PRESERVE=""
   fi

   FOUND="`ls -A1d $DIR/$2 2>/dev/null | head -n 1 | tr -s '/'`"

   if [ "$FOUND" = "" ]; then
      if [ "$PRESERVE" != "true" ]; then
         umount $DIR 2>/dev/null
         rmdir $DIR 2>/dev/null
      fi
      return 1
   else
      # remount without the 'ro' option now, so use rw or defaults
      # Only in the case it was not mounted already before.
      if [ "$PRESERVE" != "true" ]; then
         umount $DIR 2>/dev/null
         mount_device $1 $DIR
         if [ $? -ne 0 ]; then
            rmdir $DIR 2>/dev/null
	    return 2
	 fi
      fi
      echo "$FOUND"
      return 0
   fi
}

# Find file in computer by mounting disks or other storage devices
# and searching for $1 in the mounted directory
# $1 = filename or device-path or devicepath/filename
#
find_file()
{
   if_debug "find_file" "$*"
   local DEVPART PATHPART

   # if parameter is just a device, echo it and exit
   if [ -b "$1" -o -c "$1" -o "$1" = "" ]; then echo "$1"; return; fi

   # If path doesn't start with /dev/, try to find the exact path on all devices
   # First, split DEV/PATH parts
   DEVPART="`echo \"$1\" | egrep_o \"(^/dev/[^/]+)\"`"

   if [ "$DEVPART" = "" ]; then
      # no device is specified. Search all devices for filename $1
      PATHPART="$1";
      ( list_mounted_directories ; list_block_devices ) | while read DEVICE; do
         find_filepath $DEVICE $PATHPART
         if [ $? -eq 0 ]; then return 0; fi
      done
   else
      # try to find PATHPART only on the given device
      PATHPART="`echo \"$1\" | egrep_o \"^/dev/[^/]+/(.*)\"`"
      find_filepath $DEVPART $PATHPART
   fi
}

# Find In Computer
# use 'find_file' function to find the given file/dir
# if nothing found, modprobe various drivers (USB/PCMCIA) and try again.
# $1 = file or directory to find
#
find_in_computer()
{
   if_debug "find_in_computer" "$*"
   local RESULT

   RESULT="`find_file \"$1\"`"
   if [ "$RESULT" = "" ]; then
      # still empty? Load USB drivers and try again
      modprobe_usb_modules >&2
      RESULT="`find_file \"$1\"`"
   fi
   if [ "$RESULT" = "" ]; then
      # even still empty? Load PCMCIA drivers and try again
      modprobe_pcmcia_modules >&2
      RESULT="`find_file \"$1\"`"
   fi

   echo $RESULT
}

# ===========================================================
# hardware preparation functions
# ===========================================================

# Create block devices to /dev described by /sys entries
#
mdev_start_hotplug()
{
   if_debug "mdev_start_hotplug" "$*"
   echolog "creating /dev entries for block devices"
   mdev -s
   echo /bin/mdev > /proc/sys/kernel/hotplug
}

# modprobe kernel modules needed for the LiveCD
#
modprobe_essential_modules()
{
   if_debug "modprobe_essential_modules" "$*"
   local PRINTK IOCHARSET

   PRINTK=`cat /proc/sys/kernel/printk`
   echo "0" >/proc/sys/kernel/printk

   IOCHARSET="`cmdline_value iocharset`"

   echolog "starting loop device support"
   modprobe_module loop max_loop=255
   echolog "starting cdrom filesystem support"
   modprobe_module isofs
   echolog "starting squashfs support"
   modprobe_module squashfs
   echolog "starting aufs support with nwkq=16 and brs=1"
   modprobe_module aufs nwkq=16 brs=1
   echolog "starting international fs support"
   modprobe_module nls_cp437
   modprobe_module nls_iso8859-1
   modprobe_module nls_$IOCHARSET
   echolog "starting vfat support"
   modprobe_module vfat
   echolog "starting ntfs support"
   modprobe_module ntfs

   echo "$PRINTK" >/proc/sys/kernel/printk
}

# Modprobe kernel modules needed for USB masstorage devices
# This function is called only if necessary (eg. you're using from= or
# changes= but the argument can't be found
#
modprobe_usb_modules()
{
   if_debug "modprobe_usb_modules" "$*"
   local PRINTK SLEEP
   PRINTK=`cat /proc/sys/kernel/printk`
   echo "0" >/proc/sys/kernel/printk

   LSPCI="`lspci -v | grep -i prog-if`"
   if [ "`echo $LSPCI | egrep -i [eou]hci`" = "" ]; then
      return
   fi

   echolog "starting USB support"
   if [ "`echo $LSPCI | grep -i ehci`" != "" ]; then
      modprobe_module ehci-hcd
   fi
   if [ "`echo $LSPCI | grep -i ohci`" != "" ]; then
      modprobe_module ohci-hcd
   fi
   if [ "`echo $LSPCI | grep -i uhci`" != "" ]; then
      modprobe_module uhci-hcd
   fi
   modprobe_module usb-storage

   SLEEP="`cmdline_value waitusb | sed -r 's/[^0-9]*([0-9]+).*/\1/'`"
   if [ "$SLEEP" = "" ]; then SLEEP=10; fi
   echolog "waiting for USB devices..."
   sleep $SLEEP
   setup_dma
   echo "$PRINTK" >/proc/sys/kernel/printk
}

modprobe_pcmcia_modules()
{
   if_debug "modprobe_pcmcia_modules" "$*"
   local PRINTK SLEEP
   PRINTK=`cat /proc/sys/kernel/printk`
   echo "0" >/proc/sys/kernel/printk

   echolog "starting PCMCIA CardBus support"
   modprobe_module pcmcia_core
   modprobe_module pcmcia
   modprobe_module rsrc_nonstatic
   modprobe_module yenta_socket

   # I have no idea if the SLEEP is required for PCMCIA, but to be safe:
   SLEEP="`cmdline_value waitpcmcia | sed -r 's/[^0-9]*([0-9]+).*/\1/'`"
   if [ "$SLEEP" = "" ]; then SLEEP=10; fi
   echolog "waiting for PCMCIA devices..."
   sleep $SLEEP

   echo "$PRINTK" >/proc/sys/kernel/printk
}

# enable/disable CD autoejecting when unmounted
# $1 = 1|0 ... enable|disable
#
cd_autoeject()
{
   if_debug "cd_autoeject" "$*"
   echo $1 >/proc/sys/dev/cdrom/autoeject
}

# Disable DMA if nodma boot parameter is present
#
setup_dma()
{
   if_debug "setup_dma" "$*"
   local DEVICE

   if [ ! "`cmdline_parameter nodma`" = "" ]; then
      for DEVICE in `list_cdrom_devices` `list_disk_devices`; do
         echolog "setting DMA support off for $DEVICE"
         hdparm -d 0 $DEVICE
      done
   fi
}

# ===========================================================
# Filesystem functions
# ===========================================================

# Get filesystem options
# $1 = filesystem
# $2 = 'fstab' or 'mount' ... 'auto'/'noauto' string is enabled (fstab) or disabled (mount)
#
fs_options()
{
   if_debug "fs_options" "$*"
   local NOAUTO IOCHARSET

   if [ "$1" = "swap" ]; then echo "noauto,defaults"; return 0; fi

   NOAUTO="`cmdline_parameter noauto`"
   if [ "$NOAUTO" = "" ]; then NOAUTO="auto"; fi
   if [ "$2" = "fstab" ]; then echo -n "$NOAUTO," ; fi
   echo -n "noatime,users,suid,dev,exec"

   IOCHARSET="`cmdline_value iocharset`"

   if [ "$1" = "vfat" -a "$IOCHARSET" ]; then echo ",iocharset=$IOCHARSET"; fi
   if [ "$1" = "ntfs" ]; then
      echo -n ",ro"
      if [ "$IOCHARSET" ]; then
         echo ",nls=$IOCHARSET"
      fi
   fi
}

# discover filesystem used on the given device
# use vfat for msdos filesystem
# $1 = device, eg. /dev/hda1
#
device_filesystem()
{
   if_debug "device_filesystem" "$*"
   blkid -s TYPE $1 | cut -d = -f 2 | tr -d ' "' | sed "s/msdos/vfat/" #| sed "s/ntfs/ntfs-3g/"
}

# $1 = fstab file
# $2 = device name
dev_is_in_fstab()
{
   if_debug "dev_is_in_fstab" "$*"
   cat "$1" | sed -r "s/#.*//" | egrep -q "^[[:space:]]*$2[[:space:]]"
}

# update given line in fstab, add new values only if the device is not found
# $1 = fstab file to parse
# $2 = device name
# $3 = mountpoint
# $4 = filesystem
# $5 = mount options
#
fstab_add_line()
{
   if_debug "fstab_add_line" "$*"
   if ! dev_is_in_fstab "$1" "$2"; then
      echo "$2" "$3" "$4" "$5" 0 0 "$FSTABLLFLAG" >>$1
   fi
}

# create correct fstab file in $1/etc/fstab and create apropriate
# mount directories in $1/mnt. Check for iocharset boot option,
# if present, add iocharset to all DOS/Win filesystems (vfat,ntfs)
# $1 = root directory (union)
#
fstab_update()
{
   if_debug "fstab_update" "$*"
   local FSTAB

   FSTAB="$1/etc/fstab"
   FSTABTMP=$FSTAB$$
   mkdir -p $1/etc $1/mnt
   cat $FSTAB 2>/dev/null | grep -v "$FSTABLLFLAG" >$FSTABTMP

   fstab_add_line $FSTABTMP tmpfs / tmpfs defaults
   fstab_add_line $FSTABTMP devpts /dev/pts devpts gid=5,mode=620
   fstab_add_line $FSTABTMP proc /proc proc defaults
   fstab_add_line $FSTABTMP sysfs /sys sysfs defaults
   list_cdrom_devices | while read DEVICE; do
      MNT="`device_mountdir $DEVICE`"
      mkdir -p "$1/$MNT"
      fstab_add_line $FSTABTMP $DEVICE $MNT iso9660 noauto,users,exec
   done
   list_partition_devices | while read DEVICE; do
      MNT="`device_mountdir $DEVICE`"
      FS="`device_filesystem $DEVICE`"
      OPT="`fs_options $FS fstab`"

      # if the partition has filesystem, add it to fstab
      if [ "$FS" != "" ]; then
         fstab_add_line $FSTABTMP $DEVICE $MNT $FS $OPT
         if [ "$FS" != "swap" ]; then mkdir -p "$1/$MNT"; fi
      fi
   done

   fstab_add_line $FSTABTMP /dev/fd0 /mnt/floppy vfat noauto,noatime,users,suid,dev,exec
   mkdir -p $1/mnt/floppy

   mv -f $FSTABTMP $FSTAB
}
